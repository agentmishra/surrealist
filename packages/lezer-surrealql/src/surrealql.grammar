@top SurrealQL {
	Expressions | WhereClause
}

@precedence {
	range @left,
	ident,
	FunctionJs,
	Int,
	RecordId,
	Ident,
	Object,
	Duration,
	number,
	ObjectContent,
	statement @cut
}

Expressions {
	(Expression ";")* Expression ";"?
}

Expression {
	Statement |
	Value
}

SubQuery {
	"("
	Expression
	")"
}

Block {
	!statement
	"{"
	Expressions
	"}"
}

Statement {
	BeginStatement |
	CancelStatement |
	CommitStatement |
	DefineStatement |
	RemoveStatement |
	InfoForStatement |
	KillStatement |
	LiveSelectStatement |
	ShowStatement |
	SleepStatement |
	UseStatement |
	OptionStatement |
	RebuildStatement |
	CreateStatement |
	SelectStatement |
	DeleteStatement |
	InsertStatement |
	BreakStatement |
	ContinueStatement |
	ForStatement |
	ReturnStatement |
	ThrowStatement |
	IfElseStatement |
	LetStatement |
	RelateStatement |
	UpdateStatement
}

// Transaction statements

BeginStatement { begin transaction? }
CancelStatement { cancel transaction? }
CommitStatement { commit transaction? }

// Define statements

DefineStatement {
	define
	(
		DefineAnalyzerStatement |
		DefineDatabaseStatement |
		DefineEventStatement |
		DefineFieldStatement |
		DefineFunctionStatement |
		DefineIndexStatement |
		DefineNamespaceStatement |
		DefineParamStatement |
		DefineScopeStatement |
		DefineTableStatement |
		DefineTokenStatement |
		DefineUserStatement
	)
}

// TODO implement filters
DefineAnalyzerStatement { analyzer Ident TokenizersClause? CommentClause? }
DefineEventStatement { event Ident OnTableClause WhenThenClause CommentClause? }
DefineDatabaseStatement { database Ident on Ident CommentClause? }

DefineFieldStatement {
	field
	IfNotExistsClause?
	Ident
	OnTableClause
	(
		TypeClause |
		DefaultClause |
		ReadonlyClause |
		ValueClause |
		AssertClause |
		PermissionsForClause |
		CommentClause
	)*
}

DefineFunctionStatement {
	function
	IfNotExistsClause?
	customFunctionName
	"("
	(
		VariableName ":" Type
		( "," VariableName ":" Type )*
	)?
	")"
	Block
	(
		PermissionsBasicClause |
		CommentClause
	)*
}

DefineIndexStatement {
	index
	IfNotExistsClause?
	Ident
	OnTableClause
	FieldsColumnsClause
	(
		UniqueClause |
		SearchAnalyzerClause |
		MtreeClause |
		HnswClause
	)
}

DefineNamespaceStatement { namespace Ident CommentClause? }

DefineParamStatement {
	param
	IfNotExistsClause?
	VariableName
	value
	Value
}

DefineScopeStatement {
	scope
	IfNotExistsClause?
	Ident
	(
		SessionClause |
		SigninClause |
		SignupClause |
		CommentClause
	)*
}

DefineTableStatement {
	table
	IfNotExistsClause?
	Ident
	(
	drop |
	(schemafull | schemaless) |
	TableTypeClause |
	TableViewClause |
	ChangefeedClause |
	PermissionsForClause |
	CommentClause
	)*
}

DefineTokenStatement {
	token
	IfNotExistsClause?
	Ident
	( on ( namespace | database | scope Ident ) )
	TokenTypeClause
	( value String )
}

DefineUserStatement {
	user
	IfNotExistsClause?
	Ident
	( on ( root | namespace | database ) )
	( ( password | passhash ) String )
	( roles commaSep<Ident> )
}

// Remove statement

RemoveStatement {
	remove
	(
	( namespace IfExistsClause? Ident ) |
	( database IfExistsClause? Ident ) |
	( user IfExistsClause? Ident on ( root | namespace | database ) ) |
	( token IfExistsClause? Ident on ( namespace | database | scope ) ) |
	( event IfExistsClause? Ident on table? Ident ) |
	( field IfExistsClause? Ident on table? Ident ) |
	( index IfExistsClause? Ident on table? Ident ) |
	( analyzer IfExistsClause? Ident ) |
	( function IfExistsClause? customFunctionName ) |
	( param IfExistsClause? VariableName ) |
	( scope IfExistsClause? Ident ) |
	( table IfExistsClause? Ident )
	)
}

// Data statements

CreateStatement {
	create only?
	createTarget { Ident | VariableName | Function }
	createContent { ContentClause | SetClause | UnsetClause | () }
	ReturnClause?
	TimeoutClause?
	ParallelClause?
}

SelectStatement {
	(select)
	(
		value Predicate |
		commaSep<InclusivePredicate>
	)
	(from)
	(only)?
	(
		Statement |
		(
			commaSep<Value>
			selectClauses1 {
				WithClause?
				WhereClause?
				SplitClause?
			}
			selectClauses2 {
				GroupClause?
				OrderClause?
				LimitStartComboClause?
			}
			selectClauses3 {
				FetchClause?
				TimeoutClause?
				ParallelClause?
				ExplainClause?
			}
		)
	)
}

DeleteStatement {
	delete only?
	(
		Statement |
		(
			commaSep<Value>
			WhereClause?
			ReturnClause?
			TimeoutClause?
			ParallelClause?
		)
	)
}

InsertStatement {
	insert
	ignore?
	into
	Ident
	(
		Object |
		( "[" commaSep<Object> "]" ) |
		(
			"(" commaSep<Ident> ")"
			values
			commaSep<(
				"(" commaSep<Value> ")"
			)>
			on duplicate key update
			commaSep<FieldAssignment>
		)
	)
}

IfElseStatement {
	if
	(
		Legacy {
			Value
			then
			( Block | SubQuery)
			(
				else if
				Value
				then
				( Block | SubQuery)
			)*
			(
				else
				( Block | SubQuery)
			)?
			end
		} |
		Modern {
			Value Block
			(
				else if
				Value Block
			)*
			(
				else Block
			)?
		}
	)
}

relateSubject { Array | Ident | Function | VariableName | RecordId }
RelateStatement {
	relate only?
	relateSubject "->" relateSubject "->" relateSubject
	( ContentClause | SetClause )?
	ReturnClause?
	TimeoutClause?
	ParallelClause?
}

InfoForStatement {
	info for
	(
		root |
		ns | namespace |
		db | database |
		( sc Ident | scope Ident) |
		( tb Ident | table Ident)
	)
	structure?
}

UpdateStatement {
	update only?
	(
		Statement |
		(
			commaSep<Value>
			updateClause1 {
				ContentClause |
				MergeClause |
				PatchClause |
				SetClause |
				UnsetClause
			}?
			updateClause2 {
				WhereClause?
				ReturnClause?
				TimeoutClause?
				ParallelClause?
			}
		)
	)
}

// Control statements
BreakStatement { break }
ContinueStatement { continue }
ForStatement { for VariableName in ( Array | VariableName | SubQuery | Block ) Block }
ReturnStatement { return Expression }
ThrowStatement { throw Value }

// Live statements
KillStatement { kill String }
LiveSelectStatement {
	live select
	(
		diff |
		value Predicate |
		commaSep<InclusivePredicate>
	)
	from commaSep<Ident>
	WhereClause?
	FetchClause?
}

// Other statements
LetStatement { let VariableName "=" Value }
ShowStatement {
	show changes for table
	Ident
	( since String )?
	( limit Int )?
}

SleepStatement {
	sleep Duration
}

useNs { ( ns | namespace ) Ident }
useDb { ( db | database ) Ident }
UseStatement {
	use
	( useNs | useDb | ( useNs useDb ) )
}

OptionStatement {
option
Ident
( "=" ( true | false ) )?
}

RebuildStatement {
rebuild index
IfExistsClause?
Ident
OnTableClause
}

// Values

BaseValue {
	String |
	number |
	true |
	false |
	null |
	none |
	VariableName |
	Ident { rawident } |
	Array |
	RecordId |
	FunctionJs |
	Function |
	SubQuery |
	Block |
	Object |
	TypeCast |
	Duration
}

Value { BaseValue | BinaryExpression }

// Binary expressions

BinaryExpression {
	BaseValue
	Operator
	BaseValue
}

// Objects

ObjectKey {
	KeyName { rawident } |
	String
}

ObjectProperty {
	ObjectKey ":" Value
}

ObjectContent {
	commaSep<ObjectProperty>
}

Object {
	objectOpen ObjectContent? "}"
}

// Arrays

Array { "[" commaSep<Value>? "]"}

// Record Ids

RecordIdIdent {
	rawident |
	tickIdent |
	bracketIdent
}

RecordIdValue {
	RecordIdIdent |
	Int |
	Array |
	Object
}

RecordIdRange {
	( RecordIdValue !range ">"? )?
	".."
	( !range "="? RecordIdValue )?
}

RecordId {
	RecordIdIdent
	":"
	( RecordIdValue | RecordIdRange )
}

// Durations

Duration {
	DurationPart+
}

// JS Functions

FunctionJs {
	function
	"(" commaSep<Value>? ")"
	javascriptBlock
}

@skip {} {
  javascriptBlock {	"{" JavaScript? "}" }
}

// Function invocation

Function {
	(functionName | customFunctionName | rand | count)
	"(" commaSep<Value>? ")"
}

// Assignment

FieldAssignment {
	Ident
	assignmentOperator
	Value
}

// Clauses

MergeClause {
	merge Object
}

PatchClause {
	patch Array
}

TableTypeClause {
	type
	(
		any |
		normal |
		(
			relation
			( ( in | from ) piped<Ident> )?
			( ( out | to ) piped<Ident> )?
		)
	)
}

TableViewClause {
	as
	select
	commaSep<InclusivePredicate>
	from
	commaSep<Value>
	WhereClause?
	GroupClause?
}

ChangefeedClause {
	changefeed
	Duration
}

SessionClause {
	session
	Duration
}

SignupClause {
	signup
	( SubQuery | Block )
}

SigninClause {
	signin
	( SubQuery | Block )
}

OnTableClause {
	on table? Ident
}

FieldsColumnsClause {
	( fields | columns ) commaSep<Ident>
}

UniqueClause {
	unique
}

SearchAnalyzerClause {
	search analyzer
	Ident
    (Bm25Clause | DocIdsOrderClause | DocLenghtsOrderClause | PostingsOrderClause |
	 TermsOrderClause | DocIdsCacheClause | DocLenghtsCacheClause | PostingsCacheClause |
	 TermsCacheClause | highlights)*
}

Bm25Clause { bm25 ( "(" Float "," Float ")")? }
DocIdsCacheClause { doc_ids_cache Int }
DocIdsOrderClause { doc_ids_order Int }
DocLenghtsCacheClause { doc_lengths_cache Int }
DocLenghtsOrderClause { doc_lengths_order Int }
PostingsCacheClause { postings_cache Int }
PostingsOrderClause { postings_order Int }
TermsCacheClause { terms_cache Int }
TermsOrderClause { terms_order Int}

MtreeClause {
	mtree
	IndexDimensionClause
	(
	MtreeDistClause |
	IndexTypeClause |
	IndexCapacityClause |
	DocIdsOrderClause |
	DocIdsCacheClause |
	MtreeCacheClause
	)*
}

MtreeCacheClause { mtree_cache Int }
MtreeDistClause { dist ( cosine | euclidean | manhattan ) }

HnswClause {
hnsw
IndexDimensionClause
	(
	HnswDistClause |
	IndexTypeClause |
	IndexCapacityClause |
	IndexLmClause |
	IndexM0Clause |
	IndexMClause |
	IndexEfcClause |
	IndexExtendCandidatesClause |
	IndexKeepPrunedConnectionsClause
	)*
}

HnswDistClause { dist ( chebyshev | cosine | euclidean | hamming | jaccard | manhattan | ( minkowski number ) | pearson ) }

IndexDimensionClause { dimension Int }
IndexTypeClause { type ( f32 | f64 | i16 | i32 | i64 ) }
IndexCapacityClause { capacity Int }
IndexLmClause { lm Float }
IndexM0Clause { m0 Int }
IndexMClause { m Int }
IndexEfcClause { efc Int }
IndexExtendCandidatesClause { extend_candidates }
IndexKeepPrunedConnectionsClause { keep_pruned_connections }

ContentClause {
	content Object
}

SetClause {
	set commaSep<FieldAssignment>
}

UnsetClause {
unset commaSep<FieldAssignment>
}

IfNotExistsClause {
	if not exists
}

IfExistsClause {
	if exists
}

ReturnClause {
	return
	( before | after | diff | commaSep<Value> )
}

TimeoutClause {
	timeout
	Duration
}

ParallelClause {
	parallel
}

FetchClause {
	fetch
	commaSep<Ident>
}

StartClause {
	start
	at?
	(Int | VariableName)
}

LimitClause {
	limit
	by?
	(Int | VariableName)
}

LimitStartComboClause {
	StartClause LimitClause? |
	LimitClause StartClause?
}

GroupClause {
	group
	by?
	commaSep<Ident>
}

OrderClause {
	order
	by?
	commaSep<Ident>
	( asc | desc )?
}

SplitClause {
	split
	at?
	Ident
}

WhereClause {
	where
	Value
}

WithClause {
	with
	(
		noindex |
		index commaSep<Ident>
	)
}

ExplainClause {
	explain
	full?
}

TokenizersClause { tokenizers commaSep<AnalyzerTokenizers> }

WhenThenClause {
	(
		when
		Value
	)?
	then?
	commaSep<(SubQuery | Block)>
}

TypeClause {
	flexible?
	type
	Type
}

ReadonlyClause {
	readonly
}

DefaultClause {
	default
	Value
}

ValueClause {
	value
	Value
}

AssertClause {
	assert
	Value
}

PermissionsForClause {
	permissions
	(
		// TODO make case insensitive but not a keyword
		none | full |
		(
			for
			commaSep<( selectPermissions | createPermissions | updatePermissions | deletePermissions )>
			( WhereClause | none | full )
		)+
	)
}

PermissionsBasicClause {
	permissions
	none | full | WhereClause
}

CommentClause {
	comment
	String
}

TokenTypeClause {
	type
	(
		jwks |
		eddsa |
		es256 |
		es384 |
		es512 |
		ps256 |
		ps384 |
		ps512 |
		rs256 |
		rs384 |
		rs512
	)
}

// Support

AnalyzerTokenizers {
	"blank" |
	"camel" |
	"class" |
	"punct"
}

Predicate {
	Value |
	Value as Ident
}

InclusivePredicate {
	"*" |
	Predicate
}

// Idiom {
// 	Ident
// 	("." Ident)*
// }

// Types

Type {
	piped<(
		StringType |
		NumberType |
		AnyType |
		BoolType |
		BytesType |
		DatetimeType |
		DecimalType |
		DurationType |
		FloatType |
		IntType |
		NullType |
		ObjectType |
		ArrayType |
		SetType |
		RecordType |
		OptionType |
		GeometryType
	)>
}

TypeBracketOpen { "<" }
TypeBracketClose { ">" }

StringType[@name="Type"] { "string" }
NumberType[@name="Type"] { "number" }
AnyType[@name="Type"] { "any" }
BoolType[@name="Type"] { "bool" }
BytesType[@name="Type"] { "bytes" }
DatetimeType[@name="Type"] { "datetime" }
DecimalType[@name="Type"] { "decimal" }
DurationType[@name="Type"] { "duration" }
FloatType[@name="Type"] { "float" }
IntType[@name="Type"] { "int" }
NullType[@name="Type"] { "null" }
ObjectType[@name="Type"] { "object" }
ArrayType[@name="Type"] { "array" ( TypeBracketOpen Type TypeBracketClose )? }
SetType[@name="Type"] { "set" ( TypeBracketOpen Type TypeBracketClose )? }
RecordType[@name="Type"] { "record" ( TypeBracketOpen piped<( rawident | Int )> TypeBracketClose )? }
OptionType[@name="Type"] { "option" ( TypeBracketOpen Type TypeBracketClose ) }
GeometryType[@name="Type"] {
	"geometry"
	(
		TypeBracketOpen
		( "feature" | "point" | "line" | "polygon" | "multipoint" | "multiline" | "multipolygon" | "collection" )
		TypeBracketClose
	)?
}

TypeCast {
	TypeBracketOpen Type TypeBracketClose BaseValue
}

// Strings
String { singleString | doubleString }

Ident {
	rawident |
	tickIdent
}

number { Int | Float | Decimal }

Int[@name=Number] { "-"? int }
Float[@name=Number] { "-"? float }
Decimal[@name=Number] { "-"? decimal }

Operator {
    binaryOperator |
	"-" | "=" | ">" | "<" |
	and |
	or |
	is |
	( is opNot ) |
	contains |
	containsnot |
	containsall |
	containsany |
	containsnone |
	inside | in |
	notinside | ( opNot opIn ) |
	allinside |
	anyinside |
	noneinside |

	outside |
	intersects |

	( "@" Int "@" ) |
	(
		"<|"
		Int
		( "," ( Int | chebyshev | cosine | euclidean | hamming | jaccard | manhattan | ( minkowski number ) | pearson ) )
		"|>"
	)
}

@external tokens objectToken from "./tokens" {
	objectOpen[@name=BraceOpen]
}

@tokens {
	// Characters
	"{"[@name=BraceOpen]
	"}"[@name=BraceClose]
	"["
	"]"
	":"[@name=Colon]
	"->"[@name=GraphRight]
	"<-"[@name=GraphLeft]

	// Helpers
	whitespace { $[ \n\r\t] }

	// Comments
	Comment { CommentHash | CommentDash | CommentSlash }
	CommentHash { "#" ![\n]* }
	CommentDash { "--" ![\n]* }
	CommentSlash { "//" ![\n]* }

	// Numbers
	int { @digit+ }
	frac { '.' @digit+ }
	exp { $[eE] $[+\-]? @digit+ }
	float { int (frac exp? | exp) "f"? }
	decimal { int frac? exp? "dec" }

	singleString { "'" ![']* "'" }
	doubleString { '"' !["]* '"' }

	// Language
	VariableName { "$" (@asciiLetter | @digit | "_" )+ }
	tickIdent {
		"`" ![`]+ '`'
	}
	bracketIdent {
		"⟨" ![⟩]+ "⟩"
	}
	rawident {
		( (@asciiLetter | "_") (@asciiLetter | @digit | "_")* ) |
		( @digit+ (@asciiLetter | "_") (@asciiLetter | @digit | "_")* )
	}

	functionNameSegment { "::" @asciiLetter+ }
	functionName[@name=function] {
		@asciiLetter+ functionNameSegment+
	}
	customFunctionName[@name=function] {
		"fn" functionNameSegment*
	}

	durationUnit { "ns" | "us" | "µs" | "ms" | "s" | "m" | "h" | "d" | "w" | "y"}
	DurationPart { int " "* durationUnit }

	@precedence { Comment "-" }
	@precedence { Comment binaryOperator }
	@precedence { customFunctionName functionName rawident }
	@precedence { float decimal int rawident }
	@precedence { DurationPart rawident }
	@precedence { DurationPart int }

	JavaScript { ![\\\n}]+ }

	binaryOperator {
		"&&" | "||" | "??" | "?:" | "!=" | "==" | "?=" | "*=" | "~" | "!~" | "*~" |
		"<=" | ">=" | "+" | "+=" | "-=" | "*" | "×" | "/"  | "÷" | "**" |
		$[∋∌⊇⊃⊅∈∉⊆⊂⊄] | "@@"
    }

	assignmentOperator[@name=Operator] {
		"="  |
		"+=" |
		"-="
	}
}

commaSep<content> {
	content ("," content)*
}

piped<content> {
	content ("|" content)*
}

@skip { whitespace | Comment }
@detectDelim

@external propSource surqlHighlighting from "./highlight"

@external extend { rawident } tokens from "./tokens" {
	analyzer				[@name=Keyword],
	any						[@name=Keyword],
	as						[@name=Keyword],
	asc						[@name=Keyword],
	assert					[@name=Keyword],
	at						[@name=Keyword],
	begin					[@name=Keyword],
	bm25					[@name=Keyword],
	break					[@name=Keyword],
	by						[@name=Keyword],
	cancel					[@name=Keyword],
	capacity				[@name=Keyword],
	changefeed				[@name=Keyword],
	changes					[@name=Keyword],
	columns					[@name=Keyword],
	comment					[@name=Keyword],
	commit					[@name=Keyword],
	content					[@name=Keyword],
	continue				[@name=Keyword],
	create					[@name=Keyword],
	database				[@name=Keyword],
	db						[@name=Keyword],
	default					[@name=Keyword],
	define					[@name=Keyword],
	delete					[@name=Keyword],
	desc					[@name=Keyword],
	dimension				[@name=Keyword],
	dist					[@name=Keyword],
	doc_ids_cache			[@name=Keyword],
	doc_ids_order			[@name=Keyword],
	doc_lengths_cache		[@name=Keyword],
	doc_lengths_order		[@name=Keyword],
	drop					[@name=Keyword],
	duplicate				[@name=Keyword],
	efc						[@name=Keyword],
	else					[@name=Keyword],
	end						[@name=Keyword],
	exists					[@name=Keyword],
	explain					[@name=Keyword],
	extend_candidates		[@name=Keyword],
	event					[@name=Keyword],
	fetch					[@name=Keyword],
	field					[@name=Keyword],
	fields					[@name=Keyword],
	flexible				[@name=Keyword],
	for						[@name=Keyword],
	from					[@name=Keyword],
	group					[@name=Keyword],
	highlights				[@name=Keyword],
	hnsw					[@name=Keyword],
	if						[@name=Keyword],
	ignore					[@name=Keyword],
	in						[@name=Keyword],
	index					[@name=Keyword],
	info					[@name=Keyword],
	insert					[@name=Keyword],
	into					[@name=Keyword],
	keep_pruned_connections	[@name=Keyword],
	key						[@name=Keyword],
	kill					[@name=Keyword],
	let						[@name=Keyword],
	limit					[@name=Keyword],
	live					[@name=Keyword],
	lm						[@name=Keyword],
	m						[@name=Keyword],
	m0						[@name=Keyword],
	merge					[@name=Keyword],
	mtree					[@name=Keyword],
	mtree_cache				[@name=Keyword],
	namespace				[@name=Keyword],
	noindex					[@name=Keyword],
	normal					[@name=Keyword],
	not						[@name=Keyword],
	ns						[@name=Keyword],
	on						[@name=Keyword],
	only					[@name=Keyword],
	option					[@name=Keyword],
	order					[@name=Keyword],
	out						[@name=Keyword],
	parallel				[@name=Keyword],
	param					[@name=Keyword],
	passhash				[@name=Keyword],
	password				[@name=Keyword],
	patch					[@name=Keyword],
	permissions				[@name=Keyword],
	postings_cache			[@name=Keyword],
	postings_order			[@name=Keyword],
	readonly				[@name=Keyword],
	rebuild					[@name=Keyword],
	relate					[@name=Keyword],
	relation				[@name=Keyword],
	remove					[@name=Keyword],
	return					[@name=Keyword],
	roles					[@name=Keyword],
	root					[@name=Keyword],
	sc						[@name=Keyword],
	scope					[@name=Keyword],
	schemafull				[@name=Keyword],
	schemaless				[@name=Keyword],
	search					[@name=Keyword],
	select					[@name=Keyword],
	session					[@name=Keyword],
	set						[@name=Keyword],
	show					[@name=Keyword],
	since					[@name=Keyword],
	signin					[@name=Keyword],
	signup					[@name=Keyword],
	sleep					[@name=Keyword],
	split					[@name=Keyword],
	start					[@name=Keyword],
	structure				[@name=Keyword],
	tb						[@name=Keyword],
	table					[@name=Keyword],
	terms_cache				[@name=Keyword],
	terms_order				[@name=Keyword],
	then					[@name=Keyword],
	throw					[@name=Keyword],
	timeout					[@name=Keyword],
	to						[@name=Keyword],
	token					[@name=Keyword],
	tokenizers				[@name=Keyword],
	transaction				[@name=Keyword],
	type					[@name=Keyword],
	unique					[@name=Keyword],
	unset					[@name=Keyword],
	update					[@name=Keyword],
	use						[@name=Keyword],
	user					[@name=Keyword],
	value					[@name=Keyword],
	values					[@name=Keyword],
	when					[@name=Keyword],
	where					[@name=Keyword],
	with					[@name=Keyword],

	// Literals
	after					[@name=Literal],
	before					[@name=Literal],
	diff					[@name=Literal],
	false					[@name=Literal],
	full					[@name=Literal],
	none					[@name=Literal],
	null					[@name=Literal],
	true					[@name=Literal],

	f32						[@name=Literal],
	f64						[@name=Literal],
	i16						[@name=Literal],
	i32						[@name=Literal],
	i64						[@name=Literal],

	selectPermissions			[@name=PermissionTarget],
	updatePermissions			[@name=PermissionTarget],
	createPermissions			[@name=PermissionTarget],
	deletePermissions			[@name=PermissionTarget],

	jwks						[@name=TokenType],
	eddsa						[@name=TokenType],
	es256						[@name=TokenType],
	es384						[@name=TokenType],
	es512						[@name=TokenType],
	ps256						[@name=TokenType],
	ps384						[@name=TokenType],
	ps512						[@name=TokenType],
	rs256						[@name=TokenType],
	rs384						[@name=TokenType],
	rs512						[@name=TokenType],

	// Operators
	and,
	or,
	is,
	opNot,
	opIn,
	contains,
	containsnot,
	containsall,
	containsany,
	containsnone,
	inside,
	notinside,
	allinside,
	anyinside,
	noneinside,
	outside,
	intersects,

	chebyshev 				[@name=Distance],
	cosine					[@name=Distance],
	euclidean				[@name=Distance],
	hamming					[@name=Distance],
	jaccard					[@name=Distance],
	manhattan				[@name=Distance],
	minkowski				[@name=Distance],
	pearson					[@name=Distance],

	function,
	rand[@name=function],
	count[@name=function]
}
